"use strict";
exports.__esModule = true;
var stripAccents = function(str) {
  var accents =
    "ÀÁÂÃÄÅàáâãäåÒÓÔÕÕÖØòóôõöøÈÉÊËèéêëðÇçÐÌÍÎÏìíîïÙÚÛÜùúûüÑñŠšŸÿýŽž";
  var fixes = "AAAAAAaaaaaaOOOOOOOooooooEEEEeeeeeCcDIIIIiiiiUUUUuuuuNnSsYyyZz";
  var split = accents.split("").join("|");
  var reg = new RegExp("(" + split + ")", "g");
  function replacement(a) {
    return fixes[accents.indexOf(a)] || "";
  }
  return str.replace(reg, replacement);
};
var harmonize = function(text, delimiter) {
  return stripAccents(text)
    .trim()
    .toLowerCase()
    .replace(/\s+/g, delimiter)
    .replace(new RegExp("/[^a-z" + delimiter + "]/g"), "");
};
var slugify = function(node, options) {
  if (options === void 0) {
    options = { delimiter: "-", prefix: "" };
  }
  if (!options.delimiter) options.delimiter = "-";
  if (!options.prefix) options.prefix = "";
  if (!node || typeof node === "boolean") {
    return "";
  }
  var delimiter = options.delimiter,
    prefix = options.prefix;
  // string
  if (typeof node === "string")
    return harmonize(prefix + " " + node, delimiter);
  // number
  if (typeof node === "number")
    return harmonize(prefix + " " + node, delimiter);
  // empty object
  if (typeof node === "object" && Object.keys(node).length === 0) {
    return "";
  }
  // We did the check about empty object before
  // const castedNode = node as React.ReactElement<any> | React.ReactNodeArray | React.ReactPortal;
  // ReactPortal
  if ("children" in node) {
    return slugify(node.children);
  }
  // ReactNodeArray
  if (node instanceof Array) {
    return slugify(
      node
        .map(function(n) {
          return slugify(n, { delimiter: delimiter });
        })
        .join(delimiter),
      options
    );
  }
  // ReactElement
  if ("type" in node) return slugify(node.props.children, options);
  // unhandled case
  return "";
};
exports["default"] = slugify;
//# sourceMappingURL=slugify.js.map
